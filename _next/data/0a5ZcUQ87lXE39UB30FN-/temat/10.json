{"pageProps":{"subject":{"id":10,"name":"RSA","description":"<p><strong>RSA</strong> - asymetryczny algorytm szyfrujący. W\r\n            tym algorytmie generujemy dwa klucze: publiczny do szyfrowania i prywatny\r\n            do deszyfrowania.</p>\r\n            <h3>Generowanie kluczy</h3>\r\n            <ol>\r\n                <li>Wybieramy dwie duże liczby pierwsze p i q.</li>\r\n                <li>Obliczamy: Ø = (p - 1) × (q - 1) oraz n = p × q</li>\r\n                <li>Znajdujemy: dowolne e, które jest względnie pierwsze z Ø (NWD(e, Ø) = 1) i nieparzyste</li>\r\n                <li>Obliczamy: d = odwrotność modulo Ø do liczby e, czyli spełnia równanie d × e mod Ø = 1.\r\n                    (Można to zrobić w sposób naiwny lub zastosować rozszerzony algorytm Euklidesa) </li>\r\n                <li>Klucz publiczny: (e, n)</li>\r\n                <li>Klucz prywatny: (d, n)</li>\r\n            </ol>\r\n            <h3>Szyfrowanie</h3>\r\n            <ul>\r\n                <li>t - liczba do zaszyfrowania</li>\r\n                <li>c - zaszyfrowana liczba</li>\r\n                <li>c = t <sup>e</sup> mod n</li>\r\n            </ul>\r\n            <h3>Deszyfrowanie</h3>\r\n            <ul>\r\n                <li>t = c <sup>d</sup> mod n</li>\r\n            </ul>","code":"int fast_power(int base, int exp, int mod)\r\n{\r\n    int res = 1;\r\n    while (exp > 0) {\r\n        if (exp % 2 == 1) {\r\n            res = (res * base) % mod;\r\n        }\r\n        base = (base * base) % mod;\r\n        exp /= 2;\r\n    }\r\n    return res;\r\n}\r\n\r\nint nwd(int a, int b)\r\n{\r\n    if (b != 0) {\r\n        return nwd(b, a % b);\r\n    }\r\n    return a;\r\n}\r\n\r\nvoid generate_keys()\r\n{\r\n    const int PRIMES[] = {\r\n        11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47\r\n    };\r\n    int p, q;\r\n\r\n    srand(time(0));\r\n    do {\r\n        p = PRIMES[rand() % 11];\r\n        q = PRIMES[rand() % 11];\r\n    } while (p == q);\r\n\r\n    int euler = (p - 1) * (q - 1);\r\n    int n = p * q;\r\n\r\n    int e = 3;\r\n    while (nwd(e, euler) != 1) {\r\n        e += 2;\r\n    }\r\n\r\n    int d = 2;\r\n    while (e * d % euler != 1) {\r\n        d++;\r\n    }\r\n\r\n    cout << \"n: \" << n << '\\n';\r\n    cout << \"public key: \" << e << '\\n';\r\n    cout << \"private key: \" << d << '\\n';\r\n}\r\n\r\nint encrypt(int t, int e, int n) {\r\n    return fast_power(t, e, n);\r\n}\r\n\r\nint decrypt(int c, int d, int n) {\r\n    return fast_power(c, d, n);\r\n}"}},"__N_SSG":true}