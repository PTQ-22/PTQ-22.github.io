{"pageProps":{"subject":{"id":30,"name":"Playfair","description":"<p>Szyfr Playfair to poligramowy szyfr podstawieniowy, który polega na\r\n                zastępowaniu par liter tekstu jawnego inną parą liter.</p>\r\n            <p> Pary nie mogą się składać z tych samych liter, więc jeśli parę tworzą te same\r\n            litery to rozdzielamy je znakiem 'X'. Długość tekstu musi być również parzysta, więc\r\n            jeśli nie jest to dodajemy na koniec 'X'.</p>\r\n            <p>Do szyfrowania\r\n            wykorzystujemy klucz, który wypisujemy do tabelki 5x5 i\r\n            dopełniamy ją pozostałymi literami alfabetu.\r\n            Każda litera występuje w tabeli raz oraz pomijamy literę 'I'.\r\n                Ewentualne litery \"I\" w tekście jawnym zamieniamy na \"J\".</p>\r\n\r\n","code":"const int LETTERS = 26;\r\nbool is_letter_used[LETTERS];\r\n\r\nconst int TAB_SIZE = 5;\r\nchar table[TAB_SIZE][TAB_SIZE];\r\n\r\nstring cut_key(string key)\r\n{\r\n    string new_key = \"\";\r\n    for (char c : key) {\r\n        if (!is_letter_used[c - 'A']) {\r\n            new_key += c;\r\n            is_letter_used[c - 'A'] = true;\r\n        }\r\n    }\r\n    return new_key;\r\n}\r\n\r\nstring prepare_text(string text)\r\n{\r\n    for (int i = 0; i < text.length(); i += 2) {\r\n        if (text[i] == text[i + 1]) {\r\n            text.insert(i + 1, \"X\");\r\n        }\r\n    }\r\n    if (text.length() % 2) {\r\n        text += \"X\";\r\n    }\r\n    return text;\r\n}\r\n\r\nvoid fill_table(string key)\r\n{\r\n    int i = 0;\r\n    int j = 0;\r\n    // wypełnienie kluczem\r\n    for (char c : key) {\r\n        table[i][j++] = c;\r\n        if (j == TAB_SIZE) {\r\n            j = 0;\r\n            ++i;\r\n        }\r\n    }\r\n    // dopełnienie alfabetem\r\n    for (int k = 0; k < LETTERS; ++k) {\r\n        if (!is_letter_used[k]) {\r\n            table[i][j++] = char(k + 'A');\r\n            if (j == TAB_SIZE) {\r\n                j = 0;\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nstruct Pos {\r\n    int x, y;\r\n};\r\n\r\nstring encrypt(string text, string key)\r\n{\r\n    is_letter_used['J' - 'A'] = true; // nie używamy j\r\n    key = cut_key(key); // przycinamy klucz jeśli zawiera powtórzenia\r\n    text = prepare_text(text); // dodanie X jeśli trzeba\r\n    fill_table(key);\r\n\r\n    string encrypted = \"\";\r\n    for (int k = 0; k < text.length(); k += 2) {\r\n        Pos first, second;\r\n        // znalezienie pozycji obecnej pary\r\n        for (int i = 0; i < TAB_SIZE; ++i) {\r\n            for (int j = 0; j < TAB_SIZE; ++j) {\r\n                if (table[i][j] == text[k]) {\r\n                    first.x = i;\r\n                    first.y = j;\r\n                }\r\n                if (table[i][j] == text[k + 1]) {\r\n                    second.x = i;\r\n                    second.y = j;\r\n                }\r\n            }\r\n        }\r\n        if (first.x == second.x) {\r\n            encrypted += table[first.x][(first.y + 1) % TAB_SIZE];\r\n            encrypted += table[first.x][(second.y + 1) % TAB_SIZE];\r\n        }\r\n        else if (first.y == second.y) {\r\n            encrypted += table[(first.x + 1) % TAB_SIZE][first.y];\r\n            encrypted += table[(second.x + 1) % TAB_SIZE][first.y];\r\n        }\r\n        else {\r\n            encrypted += table[first.x][second.y];\r\n            encrypted += table[second.x][first.y];\r\n        }\r\n    }\r\n    return encrypted;\r\n}\r\n"}},"__N_SSG":true}