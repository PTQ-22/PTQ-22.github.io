{"pageProps":{"subject":{"id":18,"name":"Lista dwukierunkowa","description":"<p><strong>Lista dwukierunkowa</strong> - lista, która różni się od jednokierunkowej tym, że każdy jej element posiada adres nie tylko do elementu za nim, ale również do elementu przed nim. Pozwala to na łatwiejsze wykonywanie niektórych operacji np. usuwania elementów z środka listy</p>","code":"struct Person {\r\n    string name, surname;\r\n    int age;\r\n};\r\n\r\nstruct Node {\r\n    Node* prev;\r\n    Person person;\r\n    Node* next;\r\n};\r\n\r\nNode* first = nullptr;\r\nNode* last = nullptr;\r\nint list_size = 0;\r\n\r\nvoid push_front(Person person)\r\n{\r\n    Node *tmp = new Node;\r\n    tmp->next = first;\r\n    tmp->prev = nullptr;\r\n    tmp->person = person;\r\n\r\n    if (first == nullptr) {\r\n        last = tmp;\r\n        first = tmp;\r\n    }\r\n    else {\r\n        first->prev = tmp;\r\n        first = tmp;\r\n    }\r\n    list_size++;\r\n}\r\n\r\nvoid push_back(Person person)\r\n{\r\n    Node *tmp = new Node;\r\n    tmp->next = nullptr;\r\n    tmp->prev = last;\r\n    tmp->person = person;\r\n\r\n    if (first == nullptr) {\r\n        first = tmp;\r\n        last = tmp;\r\n    }\r\n    else {\r\n        last->next = tmp;\r\n        last = tmp;\r\n    }\r\n    list_size++;\r\n}\r\n\r\nPerson pop_front()\r\n{\r\n    Person res = first->person;\r\n    first = first->next;\r\n    first->prev = nullptr;\r\n    list_size--;\r\n    return res;\r\n}\r\n\r\nPerson pop_back()\r\n{\r\n    Person res = last->person;\r\n    last = last->prev;\r\n    last->next = nullptr;\r\n    list_size--;\r\n    return res;\r\n}\r\n\r\nPerson pop(int index)\r\n{\r\n    Node* ptr = first;\r\n\r\n    for (int i = 0; i < index; ++i) {\r\n        ptr = ptr->next;\r\n        if (ptr == nullptr)\r\n            return {\"-1\", \"-1\", -1};\r\n    }\r\n\r\n    Person res = ptr->person;\r\n\r\n    ptr->prev->next = ptr->next;\r\n    ptr->next->prev = ptr->prev;\r\n\r\n    list_size--;\r\n    return res;\r\n}\r\n\r\nvoid push_behind(Person person, int index)\r\n{\r\n    Node* ptr = first;\r\n\r\n    for (int i = 0; i < index; ++i) {\r\n        ptr = ptr->next;\r\n        if (ptr == nullptr)\r\n            return;\r\n    }\r\n    Node *tmp = new Node;\r\n    tmp->person = person;\r\n    tmp->prev = ptr;\r\n    tmp->next = ptr->next;\r\n\r\n    ptr->next->prev = tmp;\r\n    ptr->next = tmp;\r\n    list_size++;\r\n}\r\n\r\nvoid push_before(Person person, int index)\r\n{\r\n    Node* ptr = first;\r\n\r\n    for (int i = 0; i < index; ++i) {\r\n        ptr = ptr->next;\r\n        if (ptr == nullptr)\r\n            return;\r\n    }\r\n    Node *tmp = new Node;\r\n    tmp->person = person;\r\n    tmp->prev = ptr->prev;\r\n    tmp->next = ptr;\r\n\r\n    ptr->prev->next = tmp;\r\n    ptr->prev = tmp;\r\n    list_size++;\r\n}\r\n\r\nvoid printList()\r\n{\r\n    Node* ptr = first;\r\n    int counter = 0;\r\n    while (ptr != nullptr) {\r\n        Person p = ptr->person;\r\n        cout << counter++ << ' ';\r\n        cout << p.name << ' ' << p.surname << ' ' << p.age << '\\n';\r\n        ptr = ptr->next;\r\n    }\r\n}\r\n\r\nvoid printReversedList()\r\n{\r\n    Node* ptr = last;\r\n    int counter = list_size - 1;\r\n    while (ptr != nullptr) {\r\n        Person p = ptr->person;\r\n        cout << counter-- << ' ';\r\n        cout << p.name << ' ' << p.surname << ' ' << p.age << '\\n';\r\n        ptr = ptr->prev;\r\n    }\r\n}\r\n"}},"__N_SSG":true}