{"pageProps":{"subject":{"id":28,"name":"Najkrótsza ścieżka w grafie nieważonym - BFS","description":"Za pomocą algorytmu BFS możemy znaleźć najkrótszą ścieżkę w grafie NIEWAŻONYM. Dla grafów ważonych konieczne będzie zastosowanie np. algorytmu Dijkstry.","code":"#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nconstexpr int MAXN = 101;\r\nvector<int> graph[MAXN];\r\nint dist[MAXN];\r\nint pred[MAXN];\r\n\r\nconstexpr int INF = 1e9;\r\n\r\nvoid bfs(int start, int n)\r\n{\r\n    for (int i = 0; i <= n; ++i) {\r\n        dist[i] = INF;\r\n    }\r\n    queue<int> q;\r\n    q.push(start);\r\n    dist[start] = 0;\r\n    pred[start] = -1;\r\n    while (!q.empty()) {\r\n        int v = q.front();\r\n        q.pop();\r\n        for (int u : graph[v]) {\r\n            if (dist[u] == INF) {\r\n                dist[u] = dist[v] + 1;\r\n                pred[u] = v;\r\n                q.push(u);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvector<int> construct_path(int end)\r\n{\r\n    vector<int> path;\r\n    int curr = end;\r\n    while (pred[curr] != -1) {\r\n        path.push_back(curr);\r\n        curr = pred[curr];\r\n    }\r\n    reverse(path.begin(), path.end());\r\n    return path;\r\n}\r\n\r\nint main()\r\n{\r\n    int n, m;\r\n    cin >> n >> m;\r\n    int a, b;\r\n    for (int i = 1; i <= m; ++i) {\r\n        cin >> a >> b;\r\n        graph[a].push_back(b);\r\n        graph[b].push_back(a);\r\n    }\r\n    int start, end;\r\n    cin >> start >> end;\r\n\r\n    bfs(start, n);\r\n\r\n    vector<int> path = construct_path(end);\r\n    cout << \"Shortest path from \" << start << \" to \" << end << \":\\n\";\r\n    cout << start;\r\n    for (int i : path) {\r\n        cout << \" -> \" << i;\r\n    }\r\n}"}},"__N_SSG":true}