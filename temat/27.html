<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Programowanie i Algorytmika</title><meta name="next-head-count" content="3"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3433a2a2d0cf6fb6.js" defer=""></script><script src="/_next/static/chunks/framework-9b5d6ec4444c80fa.js" defer=""></script><script src="/_next/static/chunks/main-3123a443c688934f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-dde6f6d9ff81fd35.js" defer=""></script><script src="/_next/static/chunks/664-ac1349529b76e794.js" defer=""></script><script src="/_next/static/chunks/589-41a19a63300fd6d7.js" defer=""></script><script src="/_next/static/chunks/pages/temat/%5Bid%5D-f2a028b549d66411.js" defer=""></script><script src="/_next/static/b4l7O6_bF1ZVznWoW4uNA/_buildManifest.js" defer=""></script><script src="/_next/static/b4l7O6_bF1ZVznWoW4uNA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-cfead117-0 jrQalH"><nav class="sc-5e5d03dd-0 esgUiK"><div class="sc-8cb5f743-0 iJvBAS"></div><h1>Dowolna ścieżka w grafie - DFS</h1></nav><main class="sc-aea383bf-1 hGMMpm"><section class="sc-aea383bf-2 jzqygP"><div>Algorytmem DFS możemy znaleźć dowolną ścieżkę pomiędzy dwoma wierzchołkami w grafie. Jest to jednak ścieżka DOWOLNA, niekoniecznie najkrótsza!</div></section><section class="sc-aea383bf-3 fsbWdd"><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code class="language-cpp" style="white-space:pre"><span style="color:#61aeee">#</span><span class="hljs-meta-keyword" style="color:#61aeee">include</span><span style="color:#61aeee"> </span><span style="color:#98c379">&lt;iostream&gt;</span><span>
</span><span></span><span style="color:#61aeee">#</span><span class="hljs-meta-keyword" style="color:#61aeee">include</span><span style="color:#61aeee"> </span><span style="color:#98c379">&lt;vector&gt;</span><span>
</span><span></span><span style="color:#61aeee">#</span><span class="hljs-meta-keyword" style="color:#61aeee">include</span><span style="color:#61aeee"> </span><span style="color:#98c379">&lt;algorithm&gt;</span><span>
</span><span></span><span style="color:#F92672">using</span><span> </span><span style="color:#F92672">namespace</span><span> std;
</span>
<span></span><span style="color:#F92672">constexpr</span><span> </span><span style="color:#F92672">int</span><span> MAXN = </span><span style="color:#d19a66">101</span><span>;
</span><span>vector&lt;</span><span style="color:#F92672">int</span><span>&gt; graph[MAXN];
</span><span></span><span style="color:#F92672">bool</span><span> vis[MAXN];
</span><span></span><span style="color:#F92672">int</span><span> pred[MAXN];
</span>
<span></span><span style="color:#F92672">void</span><span style="color:#61aeee"> </span><span style="color:#61aeee">dfs</span><span style="color:#61aeee">(</span><span style="color:#F92672">int</span><span style="color:#61aeee"> v, </span><span style="color:#F92672">int</span><span style="color:#61aeee"> p)</span><span style="color:#61aeee">
</span><span style="color:#61aeee"></span><span>{
</span><span>    vis[v] = </span><span style="color:#56b6c2">true</span><span>;
</span>    pred[v] = p;
<span>    </span><span style="color:#F92672">for</span><span> (</span><span style="color:#F92672">int</span><span> u : graph[v]) {
</span><span>        </span><span style="color:#F92672">if</span><span> (!vis[u]) {
</span><span>            </span><span style="color:#e6c07b">dfs</span><span>(u, v);
</span>        }
<!-- -->    }
<!-- -->}
<!-- -->
<span></span><span style="color:#61aeee">vector&lt;</span><span style="color:#F92672">int</span><span style="color:#61aeee">&gt; </span><span style="color:#61aeee">construct_path</span><span style="color:#61aeee">(</span><span style="color:#F92672">int</span><span style="color:#61aeee"> end)</span><span style="color:#61aeee">
</span><span style="color:#61aeee"></span><span>{
</span><span>    vector&lt;</span><span style="color:#F92672">int</span><span>&gt; path;
</span><span>    </span><span style="color:#F92672">int</span><span> curr = end;
</span><span>    </span><span style="color:#F92672">while</span><span> (pred[curr] != </span><span style="color:#d19a66">-1</span><span>) {
</span><span>        path.</span><span style="color:#e6c07b">push_back</span><span>(curr);
</span>        curr = pred[curr];
<!-- -->    }
<span>    </span><span style="color:#e6c07b">reverse</span><span>(path.</span><span style="color:#e6c07b">begin</span><span>(), path.</span><span style="color:#e6c07b">end</span><span>());
</span><span>    </span><span style="color:#F92672">return</span><span> path;
</span>}
<!-- -->
<span></span><span style="color:#F92672">int</span><span style="color:#61aeee"> </span><span style="color:#61aeee">main</span><span style="color:#61aeee">()</span><span style="color:#61aeee">
</span><span style="color:#61aeee"></span><span>{
</span><span>    </span><span style="color:#F92672">int</span><span> n, m;
</span>    cin &gt;&gt; n &gt;&gt; m;
<span>    </span><span style="color:#F92672">int</span><span> a, b;
</span><span>    </span><span style="color:#F92672">for</span><span> (</span><span style="color:#F92672">int</span><span> i = </span><span style="color:#d19a66">1</span><span>; i &lt;= m; ++i) {
</span>        cin &gt;&gt; a &gt;&gt; b;
<span>        graph[a].</span><span style="color:#e6c07b">push_back</span><span>(b);
</span><span>        graph[b].</span><span style="color:#e6c07b">push_back</span><span>(a);
</span>    }
<span>    </span><span style="color:#F92672">int</span><span> start, end;
</span>    cin &gt;&gt; start &gt;&gt; end;
<!-- -->
<span>    </span><span style="color:#e6c07b">dfs</span><span>(start, </span><span style="color:#d19a66">-1</span><span>);
</span>
<span>    vector&lt;</span><span style="color:#F92672">int</span><span>&gt; path = </span><span style="color:#e6c07b">construct_path</span><span>(end);
</span><span>    cout &lt;&lt; </span><span style="color:#98c379">&quot;Some path from &quot;</span><span> &lt;&lt; start &lt;&lt; </span><span style="color:#98c379">&quot; to &quot;</span><span> &lt;&lt; end &lt;&lt; </span><span style="color:#98c379">&quot;:\n&quot;</span><span>;
</span>    cout &lt;&lt; start;
<span>    </span><span style="color:#F92672">for</span><span> (</span><span style="color:#F92672">int</span><span> i : path) {
</span><span>        cout &lt;&lt; </span><span style="color:#98c379">&quot; -&gt; &quot;</span><span> &lt;&lt; i;
</span>    }
<!-- -->}</code></pre><div class="sc-ce58b15c-0 vGozJ"><div class="sc-ce58b15c-1 iIIZwY"><svg stroke="#fff" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg><span>Skopiuj</span></div><div class="sc-ce58b15c-1 iIIZwY"><svg stroke="#fff" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg><span>Pobierz</span></div></div></section></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"subject":{"id":27,"name":"Dowolna ścieżka w grafie - DFS","description":"Algorytmem DFS możemy znaleźć dowolną ścieżkę pomiędzy dwoma wierzchołkami w grafie. Jest to jednak ścieżka DOWOLNA, niekoniecznie najkrótsza!","code":"#include \u003ciostream\u003e\r\n#include \u003cvector\u003e\r\n#include \u003calgorithm\u003e\r\nusing namespace std;\r\n\r\nconstexpr int MAXN = 101;\r\nvector\u003cint\u003e graph[MAXN];\r\nbool vis[MAXN];\r\nint pred[MAXN];\r\n\r\nvoid dfs(int v, int p)\r\n{\r\n    vis[v] = true;\r\n    pred[v] = p;\r\n    for (int u : graph[v]) {\r\n        if (!vis[u]) {\r\n            dfs(u, v);\r\n        }\r\n    }\r\n}\r\n\r\nvector\u003cint\u003e construct_path(int end)\r\n{\r\n    vector\u003cint\u003e path;\r\n    int curr = end;\r\n    while (pred[curr] != -1) {\r\n        path.push_back(curr);\r\n        curr = pred[curr];\r\n    }\r\n    reverse(path.begin(), path.end());\r\n    return path;\r\n}\r\n\r\nint main()\r\n{\r\n    int n, m;\r\n    cin \u003e\u003e n \u003e\u003e m;\r\n    int a, b;\r\n    for (int i = 1; i \u003c= m; ++i) {\r\n        cin \u003e\u003e a \u003e\u003e b;\r\n        graph[a].push_back(b);\r\n        graph[b].push_back(a);\r\n    }\r\n    int start, end;\r\n    cin \u003e\u003e start \u003e\u003e end;\r\n\r\n    dfs(start, -1);\r\n\r\n    vector\u003cint\u003e path = construct_path(end);\r\n    cout \u003c\u003c \"Some path from \" \u003c\u003c start \u003c\u003c \" to \" \u003c\u003c end \u003c\u003c \":\\n\";\r\n    cout \u003c\u003c start;\r\n    for (int i : path) {\r\n        cout \u003c\u003c \" -\u003e \" \u003c\u003c i;\r\n    }\r\n}"}},"__N_SSG":true},"page":"/temat/[id]","query":{"id":"27"},"buildId":"b4l7O6_bF1ZVznWoW4uNA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>