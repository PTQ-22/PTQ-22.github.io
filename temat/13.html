<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Programowanie i Algorytmika</title><meta name="next-head-count" content="3"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3433a2a2d0cf6fb6.js" defer=""></script><script src="/_next/static/chunks/framework-9b5d6ec4444c80fa.js" defer=""></script><script src="/_next/static/chunks/main-3123a443c688934f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-dde6f6d9ff81fd35.js" defer=""></script><script src="/_next/static/chunks/664-ac1349529b76e794.js" defer=""></script><script src="/_next/static/chunks/589-41a19a63300fd6d7.js" defer=""></script><script src="/_next/static/chunks/pages/temat/%5Bid%5D-f2a028b549d66411.js" defer=""></script><script src="/_next/static/b4l7O6_bF1ZVznWoW4uNA/_buildManifest.js" defer=""></script><script src="/_next/static/b4l7O6_bF1ZVznWoW4uNA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-cfead117-0 jrQalH"><nav class="sc-5e5d03dd-0 esgUiK"><div class="sc-8cb5f743-0 iJvBAS"></div><h1>ROT13 i ROT47</h1></nav><main class="sc-aea383bf-1 hGMMpm"><section class="sc-aea383bf-2 jzqygP"><div>            <p>Szyfr Cezara to technika szyfrowania polegająca na
            zastąpieniu każdej litery tekstu jawnego inną literą,
            oddaloną od niej w alfabecie o wartość klucza.</p>

            <p>ROT13 i ROT47 to standardy szyfru przesuwającego. Są
            odpowiednikami szyfru Cezara, ich klucze wynoszą odpowiednio 13 i 47.
            Dzięki takiemu doborowi kluczy są to szyfry samoodwracalne.
                ROT13 jest samoodwracalny dla liter alfabetu, a ROT47 dla znaków ASCII od 33 do 126.
            </p></div></section><section class="sc-aea383bf-3 fsbWdd"><pre style="display:block;overflow-x:auto;padding:0.5em;color:#abb2bf;background:#282c34"><code class="language-cpp" style="white-space:pre"><span style="color:#61aeee">string </span><span style="color:#61aeee">ROT13</span><span style="color:#61aeee">(string text)</span><span style="color:#61aeee">
</span><span style="color:#61aeee"></span><span>{
</span><span>    string encrypted = </span><span style="color:#98c379">&quot;&quot;</span><span>;
</span><span>    </span><span style="color:#F92672">int</span><span> key = </span><span style="color:#d19a66">13</span><span>;
</span><span>    </span><span style="color:#F92672">int</span><span> alphabet = </span><span style="color:#d19a66">26</span><span>;
</span>
<span>    </span><span style="color:#F92672">for</span><span> (</span><span style="color:#F92672">char</span><span> c : text) {
</span><span>        </span><span style="color:#F92672">char</span><span> new_char;
</span><span>        </span><span style="color:#F92672">if</span><span> (c &gt;= </span><span style="color:#98c379">&#x27;A&#x27;</span><span> &amp;&amp; c &lt;= </span><span style="color:#98c379">&#x27;Z&#x27;</span><span>) {
</span><span>            new_char = (((c - </span><span style="color:#98c379">&#x27;A&#x27;</span><span>) + key) % alphabet) + </span><span style="color:#98c379">&#x27;A&#x27;</span><span>;
</span>        }
<span>        </span><span style="color:#F92672">else</span><span> </span><span style="color:#F92672">if</span><span> (c &gt;= </span><span style="color:#98c379">&#x27;a&#x27;</span><span> &amp;&amp; c &lt;= </span><span style="color:#98c379">&#x27;z&#x27;</span><span>) {
</span><span>            new_char = (((c - </span><span style="color:#98c379">&#x27;a&#x27;</span><span>) + key) % alphabet) + </span><span style="color:#98c379">&#x27;a&#x27;</span><span>;
</span>        }
<span>        </span><span style="color:#F92672">else</span><span> {
</span>            new_char = c;
<!-- -->        }
<!-- -->        encrypted += new_char;
<!-- -->    }
<span>    </span><span style="color:#F92672">return</span><span> encrypted;
</span>}
<!-- -->
<span></span><span style="color:#61aeee">string </span><span style="color:#61aeee">ROT47</span><span style="color:#61aeee">(string text)</span><span style="color:#61aeee">
</span><span style="color:#61aeee"></span><span>{
</span><span>    string encrypted = </span><span style="color:#98c379">&quot;&quot;</span><span>;
</span><span>    </span><span style="color:#F92672">int</span><span> key = </span><span style="color:#d19a66">47</span><span>;
</span><span>    </span><span style="color:#F92672">int</span><span> ascii_chars = </span><span style="color:#d19a66">94</span><span>;
</span>
<span>    </span><span style="color:#F92672">for</span><span> (</span><span style="color:#F92672">char</span><span> c : text) {
</span><span>        </span><span style="color:#F92672">char</span><span> new_char = (((c - </span><span style="color:#98c379">&#x27;!&#x27;</span><span>) + key) % ascii_chars) + </span><span style="color:#98c379">&#x27;!&#x27;</span><span>;
</span>        encrypted += new_char;
<!-- -->    }
<span>    </span><span style="color:#F92672">return</span><span> encrypted;
</span>}</code></pre><div class="sc-ce58b15c-0 vGozJ"><div class="sc-ce58b15c-1 iIIZwY"><svg stroke="#fff" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg><span>Skopiuj</span></div><div class="sc-ce58b15c-1 iIIZwY"><svg stroke="#fff" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg><span>Pobierz</span></div></div></section></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"subject":{"id":13,"name":"ROT13 i ROT47","description":"            \u003cp\u003eSzyfr Cezara to technika szyfrowania polegająca na\r\n            zastąpieniu każdej litery tekstu jawnego inną literą,\r\n            oddaloną od niej w alfabecie o wartość klucza.\u003c/p\u003e\r\n\r\n            \u003cp\u003eROT13 i ROT47 to standardy szyfru przesuwającego. Są\r\n            odpowiednikami szyfru Cezara, ich klucze wynoszą odpowiednio 13 i 47.\r\n            Dzięki takiemu doborowi kluczy są to szyfry samoodwracalne.\r\n                ROT13 jest samoodwracalny dla liter alfabetu, a ROT47 dla znaków ASCII od 33 do 126.\r\n            \u003c/p\u003e","code":"string ROT13(string text)\r\n{\r\n    string encrypted = \"\";\r\n    int key = 13;\r\n    int alphabet = 26;\r\n\r\n    for (char c : text) {\r\n        char new_char;\r\n        if (c \u003e= 'A' \u0026\u0026 c \u003c= 'Z') {\r\n            new_char = (((c - 'A') + key) % alphabet) + 'A';\r\n        }\r\n        else if (c \u003e= 'a' \u0026\u0026 c \u003c= 'z') {\r\n            new_char = (((c - 'a') + key) % alphabet) + 'a';\r\n        }\r\n        else {\r\n            new_char = c;\r\n        }\r\n        encrypted += new_char;\r\n    }\r\n    return encrypted;\r\n}\r\n\r\nstring ROT47(string text)\r\n{\r\n    string encrypted = \"\";\r\n    int key = 47;\r\n    int ascii_chars = 94;\r\n\r\n    for (char c : text) {\r\n        char new_char = (((c - '!') + key) % ascii_chars) + '!';\r\n        encrypted += new_char;\r\n    }\r\n    return encrypted;\r\n}"}},"__N_SSG":true},"page":"/temat/[id]","query":{"id":"13"},"buildId":"b4l7O6_bF1ZVznWoW4uNA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>